[292. 炮兵阵地](https://www.acwing.com/problem/content/294/)

#### 算法：

*DP* *状态压缩*

当前行的状态需要看上两行的状态

**状态表示 - f(i, j, k)**

- 集合：所有已经摆完前 i 行，且第 i 行的状态是 j，第 i - 1 行的状态是 k 的摆放方案

- 属性：Max

**状态计算 - 集合划分**

以第 i - 2 行的状态来划分 f(i, j, k) 表示的集合：

- 第 i - 2 行的状态是 c

  表示所有已经摆完前 i 行，且第 i 行的状态是 a，第 i - 1 行的状态是 b 的摆放方案中的最大值，等价于所有已经摆完前 i - 1 行，且第 i - 1 行的状态是 b，第 i - 2 行的状态是 c 的摆放方案中的最大值加上第 i 行的大炮数量：f(i - 1, b, c) + cnt(a)

  这个状态的存在的条件是：

  - ((a & b) | (a & c) | (b & c)) == 0
  - (g[i] & a) == 0，大炮只能放在平原上
  
  这行实际上是检查当前行摆放是否合法。所以每行只需被检测一次即可。
  检查g[i] & b时，g[i - 1] & a被上次循环，g[i - 2] : 0) & c被上上次循环检测过了。若非法相应的 f 必为0。
  快乐一种麻痹QAQ   说得很对。
  if(g[i] & b )continue; 就够了。
  
  因为如果g[i - 2]和c有冲突的话，后面的f\[i - 1 & 1]\[u][j]就是非法状态，值一定是0，是不会更新当前状态的最大值的，所以这一步判断可以省略。
  
  可以的。这里相当于只保证第i行合法，如果第i - 1行不合法，那么f\[i - 1 & 1]\[u][j]一定为0。

**Tips**

使用滚动数组的技巧：先当成不滚动来写，然后只需要把所有的第一维 & 1，就可以变成滚动数组了。

#### 时间复杂度分析：



#### 代码：

```java

```

