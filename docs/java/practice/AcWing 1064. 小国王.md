[1064. 小国王](https://www.acwing.com/problem/content/1066/)

#### 算法：

*DP* *状态压缩*

状态压缩 DP 分为：棋盘式（基于连通性）和集合式。

摆放当前行的棋子时只和上一行的状态有关系，所以我们可以根据当前行的状态将第 i 行的所有情况看成若干个集合：所有都不摆、摆一个... 每种状态看成一类，用一个集合来表示。

**状态表示 - f(i, j, s)**

- 集合：所有只摆在前 i 行，已经摆了 j 个国王，并且第 i 行摆放的状态是 s 的方案

- 属性：Count

**状态计算 - 集合划分**

以上一层的状态（2<sup>n</sup> 种）来划分 f(i, j, s) 表示的集合：

- 第 i - 1 层状态是 b

  表示所有前 i 行摆了 j 个国王，并且第 i 行的状态是 a，第 i - 1 行的状态是 b 的方案数，它等价于所有前 i - 1 行摆了 j - count(a) 个国王，并且第 i - 1 行状态是 b 的方案数：f(i - 1, j - count(a), b)

  这个状态存在的条件是：

  - 第 i - 1 行内部不能有两个 1 相邻

  - 第 i - 1 行和第 i 行之间不能相互攻击到

    - (a & b) == 0

    - (a | b) 不能有两个相邻的 1

    其中 a 表示第 i 行的状态，b 表示第 i - 1 行的状态。

**Tips**

我们可以假设一共摆到了 n + 1 行，这样 f(n + 1, m, 0) 表示第 n + 1 行一个都没有摆，等价于摆放 n 行的所有方案，这样就不用枚举第 i 行的状态来统计方案数了。

#### 时间复杂度分析：



#### 代码：

```java

```

