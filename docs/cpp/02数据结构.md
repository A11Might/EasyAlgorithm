# 数据结构

链表、栈与队列、单调队列、单调栈、kmp、Trie、并查集、堆、Hash 表。

---

#### 单链表

```cpp
// head 存储链表头，e[] 存储节点的值，ne[] 存储节点的 next 指针，idx 表示当前用到了哪个节点
int head, e[N], ne[N], idx;

// 初始化
void init() {
    head = -1;
    idx = 0;
}

// 在链表头插入一个数 a
void insert(int a) {
    e[idx] = a, ne[idx] = head, head = idx++;
}

// 将头结点删除，需要保证头结点存在
void remove() {
    head = ne[head];
}
```

#### 双链表

```cpp
// e[] 表示节点的值，l[] 表示节点的左指针，r[] 表示节点的右指针，idx 表示当前用到了哪个节点
int e[N], l[N], r[N], idx;

// 初始化
void init() {
    // 0 是左端点，1 是右端点
    r[0] = 1, l[1] = 0;
    idx = 2;
}

// 在节点 a 的右边插入一个数 x
void insert(int a, int x) {
    e[idx] = x;
    l[idx] = a, r[idx] = r[a];
    l[r[a]] = idx, r[a] = idx++;
}

// 删除节点 a
void remove(int a) {
    l[r[a]] = l[a];
    r[l[a]] = r[a];
}
```

#### 栈

```cpp
// tt 表示栈顶
int stk[N], tt = 0;

// 向栈顶插入一个数
stk[++tt] = x;

// 从栈顶弹出一个数
tt-- ;

// 栈顶的值
stk[tt];

// 判断栈是否为空
if (tt > 0) {}
```

#### 队列

- 普通队列

  ```cpp
  // hh 表示队头，tt 表示队尾
  int q[N], hh = 0, tt = -1;
  
  // 向队尾插入一个数
  q[++tt] = x;
  
  // 从队头弹出一个数
  hh++ ;
  
  // 队头的值
  q[hh];
  
  // 判断队列是否为空
  if (hh <= tt) {}
  ```

- 循环队列

  ```cpp
  // hh 表示队头，tt 表示队尾的后一个位置
  int q[N], hh = 0, tt = 0;
  
  // 向队尾插入一个数
  q[tt++] = x;
  if (tt == N) tt = 0;
  
  // 从队头弹出一个数
  hh++;
  if (hh == N) hh = 0;
  
  // 队头的值
  q[hh];
  
  // 判断队列是否为空
  if (hh != tt) {}
  ```

#### 单调栈

常见模型：找出每个数左边离它最近的比它大/小的数。

```cpp
int tt = 0;
for (int i = 1; i <= n; i++) {
    while (tt && check(stk[tt], i)) tt--;
    stk[++tt] = i;
}
```

#### 单调队列

常见模型：找出滑动窗口中的最大值/最小值。

```cpp
int hh = 0, tt = -1;
for (int i = 0; i < n; i++) {
    while (hh <= tt && check_out(q[hh])) hh++;  // 判断队头是否滑出窗口
    while (hh <= tt && check(q[tt], i)) tt--;
    q[++tt] = i;
}
```

#### KMP

```cpp
// s[] 是长文本，p[] 是模式串，n 是 s 的长度，m 是 p 的长度
// 求模式串的Next数组：
for (int i = 2, j = 0; i <= m; i++) {
    while (j && p[i] != p[j + 1]) j = ne[j];
    if (p[i] == p[j + 1]) j++;
    ne[i] = j;
}

// 匹配
for (int i = 1, j = 0; i <= n; i++) {
    while (j && s[i] != p[j + 1]) j = ne[j];
    if (s[i] == p[j + 1]) j++;
    if (j == m) {
        j = ne[j];
        // 匹配成功后的逻辑
    }
}
```

#### Trie树

```cpp
int son[N][26], cnt[N], idx;
// 0 号点既是根节点，又是空节点
// son[][] 存储树中每个节点的子节点
// cnt[] 存储以每个节点结尾的单词数量

// 插入一个字符串
void insert(char *str) {
    int p = 0;
    for (int i = 0; str[i]; i++) {
        int u = str[i] - 'a';
        if (!son[p][u]) son[p][u] = ++idx;
        p = son[p][u];
    }
    cnt[p]++;
}

// 查询字符串出现的次数
int query(char *str) {
    int p = 0;
    for (int i = 0; str[i]; i++) {
        int u = str[i] - 'a';
        if (!son[p][u]) return 0;
        p = son[p][u];
    }
    return cnt[p];
} 
```

#### 并查集

- 朴素并查集

  ```cpp
  int p[N]; //存储每个点的祖宗节点
  
  // 返回 x 的祖宗节点
  int find(int x) {
      if (p[x] != x) p[x] = find(p[x]);
      return p[x];
  }
  
  // 初始化，假定节点编号是 1 ~ n
  for (int i = 1; i <= n; i++) p[i] = i;
  
  // 合并 a 和 b 所在的两个集合：
  p[find(a)] = find(b);
  ```

- 维护size的并查集

  ```cpp
  // p[] 存储每个点的祖宗节点, size[] 只有祖宗节点的有意义，表示祖宗节点所在集合中的点的数量
  int p[N], size[N];
  
  // 返回 x 的祖宗节点
  int find(int x) {
      if (p[x] != x) p[x] = find(p[x]);
      return p[x];
  }
  
  // 初始化，假定节点编号是 1 ~ n
  for (int i = 1; i <= n; i++) {
      p[i] = i;
      size[i] = 1;
  }
  
  // 合并 a 和 b 所在的两个集合：
  size[find(b)] += size[find(a)];
  p[find(a)] = find(b);
  ```

- 维护到祖宗节点距离的并查集

  ```cpp
  // p[] 存储每个点的祖宗节点, d[x] 存储 x 到 p[x] 的距离
  int p[N], d[N];
  
  // 返回 x 的祖宗节点
  int find(int x) {
  	if (p[x] != x) {
          int u = find(p[x]);
          d[x] += d[p[x]];
          p[x] = u;
  	}
  	return p[x];
  }
  
  // 初始化，假定节点编号是 1 ~ n
  for (int i = 1; i <= n; i++) {
      p[i] = i;
      d[i] = 0;
  }
  
  // 合并 a 和 b 所在的两个集合：
  p[find(a)] = find(b);
  d[find(a)] = distance; // 根据具体问题，初始化 find(a) 的偏移量
  ```

#### 堆

```cpp
// h[N] 存储堆中的值, h[1] 是堆顶，x 的左儿子是 2x, 右儿子是 2x + 1
// ph[k] 存储第 k 个插入的点在堆中的位置
// hp[k] 存储堆中下标是 k 的点是第几个插入的
int h[N], ph[N], hp[N], size;

// 交换两个点，及其映射关系
void heap_swap(int a, int b) {
    swap(ph[hp[a]],ph[hp[b]]);
    swap(hp[a], hp[b]);
    swap(h[a], h[b]);
}

void down(int u) {
    int t = u;
    if (u * 2 <= size && h[u * 2] < h[t]) t = u * 2;
    if (u * 2 + 1 <= size && h[u * 2 + 1] < h[t]) t = u * 2 + 1;
    if (u != t) {
        heap_swap(u, t);
        down(t);
    }
}

void up(int u) {
    while (u / 2 && h[u] < h[u / 2]) {
        heap_swap(u, u / 2);
        u >>= 1;
    }
}

// O(n) 建堆
for (int i = n / 2; i; i--) down(i);
```

#### 一般哈希

- 拉链法

  ```cpp
  int h[N], e[N], ne[N], idx;
  
  // 向哈希表中插入一个数
  void insert(int x) {
      int k = (x % N + N) % N;
      e[idx] = x;
      ne[idx] = h[k];
      h[k] = idx++;
  }
  
  // 在哈希表中查询某个数是否存在
  bool find(int x) {
      int k = (x % N + N) % N;
      for (int i = h[k]; i != -1; i = ne[i]) {
          if (e[i] == x) return true;
      }
  
      return false;
  }
  ```

- 开放寻址法

  ```cpp
  int h[N];
  
  // 如果 x 在哈希表中，返回 x 的下标；如果 x 不在哈希表中，返回 x 应该插入的位置
  int find(int x) {
      int t = (x % N + N) % N;
      while (h[t] != null && h[t] != x) {
          t++;
          if (t == N) t = 0;
      }
      return t;
  }
  ```

#### 字符串哈希

核心思想：将字符串看成 P 进制数，P 的经验值是 131 或 13331，取这两个值的冲突概率低。

小技巧：取模的数用 2<sup>64</sup>，这样直接用 unsigned long long 存储，溢出的结果就是取模的结果。

```cpp
typedef unsigned long long ULL;
ULL h[N], p[N]; // h[k] 存储字符串前 k 个字母的哈希值, p[k] 存储 P^k mod 2^64

// 初始化
p[0] = 1;
for (int i = 1; i <= n; i++) {
    h[i] = h[i - 1] * P + str[i];
    p[i] = p[i - 1] * P;
}

// 计算子串 str[l ~ r] 的哈希值
ULL get(int l, int r) {
    return h[r] - h[l - 1] * p[r - l + 1];
}
```

#### C++ STL

- vector，变长数组（倍增思想）

  ```c++
  #include <vector>
  
  vector<int> a; 
  vector<int> b(10); // 定义一个长度为 10 的 vector
  vector<int> c(10, 3); // 定义一个长度为 10 的 vecotr，其中每个数都是 3
  vector<int> d({1, 2, 3});
  
  a.size() // 返回 vector 中元素个数
  a.empty() // 返回 vector 是否为空
  a.clear() // 清空 vector
  a.front() / a.back() // 返回 vector 中的第一个数/最后一个数
  a.push_back() / a.pop_back() // 向 vector 最后插入一个元素/删除一个数
  a.begin() / a.end() // vector 的迭代器（可以当做指针来看），第零个数/最后一个数后面的数
  a[idx] // 支持随机寻址
  vector<int>::iterator // vector 的迭代器类型
  
  // 遍历 vector
  for (int i = 0; i < a.size(); i++) cout << a[i] << ' ';
  for (auto i = a.begin(); i != a.end(); i++) cout << *i << ' ';
  for (auto x : a) cout << x << ' ';
  
  // 支持比较运算，按字典序
  vector<int> a(4, 3), b(3, 4);
  if (a < b) puts("a < b");
  else puts("a > b");
  ```

- pair<int, int>

  ```c++
  pair<int, string> p;
  pair<int, pair<int, int>> p2;
  p.make_pair(10, "yxc");
  p = {20, "abc"};
  p.first() / p.second() // 获取 pair 的第一个元素/第二个元素
  
  // 支持比较运算，以 first 为第一关键字，以 second 为第二关键字（字典序）
  ```

- string，字符串

  ```c++
  #include <string>
  
  string a = "yxc";
  a += "def";
  
  size() / length()
  empty()
  clear()
  
  substr(start_idx, [length]) // 返回字符串的子串
  c_str() // 返回字符串对应的字符数组的头指针
  ```

- queue，队列

  ```c++
  #include <queue>
  
  queue<int> q; 
  
  push() // 往队尾插入元素
  front() / back() // 返回队头元素/队尾元素
  pop() // 把队头弹出
  没有clear()    
      
  size()
  empty()
  q = queue<int>(); // 清空 q 时，直接重现创建即可
  ```

- priority_queue，优先队列

  ```c++
  #include <queue>
  #include <vector>
  
  priority_queue<int> heap; // 默认是大根堆
  priority_queue<int, vector<int>, greater<int> heap; // 定义小根堆
  // 使用自己定义的数据结构时
  // 如果定义大根堆则需要重载小于号，如果定义小根堆则需要重载大于号
  
  push() // 往堆中插入元素
  top() // 返回堆顶元素
  pop() // 把堆顶弹出
  没有clear()      
  ```

- stack，栈

  ```c++
  push() // 往栈顶插入元素
  top() // 返回栈顶元素
  pop() // 弹出栈顶元素
  没有clear()      
  ```

- deque，双端队列（效率较低）

  ```c++
  #include <deque>
  
  deque<int> dq;
  
  size()
  empty()
  clear()
  front() / back()
  push_back() / pop_back()
  push_front() / pop_front()
  begin() / end()
  [] // 支持随机寻址
  ```

- set, map, multiset, multimap，基于红黑树实现，动态维护有序序列

  ```c++
  // 都支持
  size()
  empty()
  clear()
  begin() / end() // 支持 ++，-- 操作，返回有序序列的前驱和后继
  
  // set / multiset
  #include <set>
  set<int> s; // 不能有重复元素
  multiset<int> ms; // 可以有重复元素
  insert() // 插入一个数
  find() // 传入 key 来查找，查找失败返回 a.end()
  count() // 返回每一个数的个数
  erase() // 输入一个数 x，删除所有 x；输入一个迭代器，删除这个迭代器
  lower_bound() / upper_bound() // 返回大于等于/大于 x 的最小的数的迭代器
  
  // map / multimap
  #include <map>
  insert() // 插入的是一个 pair
  erase() // 输入的参数是 pair 或者迭代器
  find() // 传入 key 来查找，查找失败返回 a.end()
  [] // 插入操作：a["yxc"] = 1；查找操作：a["yxc"]
  lower_bound() / upper_bound() // 返回大于等于/大于 x 的最小的数的迭代器
  ```

- unordered_set, unordered_map, unordered_multiset, unordered_multimap，基于哈希表实现

  ```c++
  #include <unorder_set>
  #include <unorder_map>
  // 与上面类似，但增删改查的时间复杂度是 O(1)，不支持 lower_bound() / upper_bound()
  ```

- bitset，压位（使用的空间是布尔数组的 1 / 8）

  ```c++
  #include <bitset>
  
  bitset<10000> s; // 定义长度为 10000 的 bitset
  ~s, &, |, ^, >>, <<, ==, != 
  []
  
  count() // 返回有多少个 1
  any() // 判断是否至少有一个 1 
  none()  // 判断是否全为 0
  set() // 将所有位置成 1
  set(k, v) // 将第 k 为变成 v
  reset() // 把所有位置成 0
  flip() // 等价于 ~
  flip(k) // 把第 k 为取反
  ```